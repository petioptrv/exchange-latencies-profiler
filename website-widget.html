<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <title>World Latencies Map</title>

    <!-- amCharts v5 -->
    <script src="https://cdn.amcharts.com/lib/5/index.js"></script>
    <script src="https://cdn.amcharts.com/lib/5/map.js"></script>
    <script src="https://cdn.amcharts.com/lib/5/xy.js"></script>   <!-- ← NEW -->
    <script src="https://cdn.amcharts.com/lib/5/geodata/worldLow.js"></script>
    <script src="https://cdn.amcharts.com/lib/5/themes/Animated.js"></script>

    <style>
        html, body {
            margin: 0;
            height: 100%
        }

        #chartdiv {
            width: 100%;
            height: 460px
        }

        #graph-title {
            font: 18px/1.2 sans-serif;
            font-weight: bold;
            color: #333;
            padding: 8px 12px;
            margin: 0;
            background: #f8f9fa;
            border-bottom: 1px solid #e9ecef
        }

        #correlation-value {
            font: 14px/1.2 monospace;
            color: #555;
            padding: 6px 12px;
            margin: 0;
            background: #f9fafb;
            border-bottom: 1px solid #e9ecef;
        }

        #graphdiv {
            width: 100%;
            min-height: 280px;
        }
    </style>
</head>
<body>
<!--<select id="menu"><option value="all">Show All</option></select>-->
<div id="chartdiv"></div>
<div id="graph-title"></div>
<div id="correlation-value"></div>
<div id="graphdiv"></div>                                      <!-- ← NEW -->

<script>
    /* ---------- 1. DATA ---------- */
    async function loadPointsFromUrl() {
        const res = await fetch("http://127.0.0.1:8081/utils/data", {headers: {"Accept": "application/json"}});
        if (!res.ok) throw new Error(`Failed to load data: ${res.status} ${res.statusText}`);
        const raw = await res.json();
        return raw.map(p => ({...p, geometry: {type: "Point", coordinates: p.coords}}));
    }

    /* ---------- 2. MAP ---------- */
    am5.ready(async function () {
        let points = [];
        try {
            points = await loadPointsFromUrl("/api/latencies"); // ← replace with your endpoint
        } catch (e) {
            console.error(e);
            return;
        }

        /* ----- Map ----- */
        const mapRoot = am5.Root.new("chartdiv");
        mapRoot.setThemes([am5themes_Animated.new(mapRoot)]);

        const chart = mapRoot.container.children.push(
            am5map.MapChart.new(mapRoot, {
                panX: "none", panY: "none",
                wheelX: "none", wheelY: "none", projection: am5map.geoEqualEarth()
            })
        );

        const polygonSeries = chart.series.push(
            am5map.MapPolygonSeries.new(mapRoot, {
                geoJSON: am5geodata_worldLow, exclude: ["AQ"],
                fill: am5.color(0x6fc5a2), stroke: am5.color(0x4e9477)
            }));
        polygonSeries.mapPolygons.template.setAll({strokeOpacity: .6, fillOpacity: .8});

        /* ---------- 3. GRAPH ---------- */
        const gRoot = am5.Root.new("graphdiv");
        gRoot.setThemes([am5themes_Animated.new(gRoot)]);

        const gChart = gRoot.container.children.push(
            am5xy.XYChart.new(gRoot, {panX: true, panY: true, wheelX: "zoomX", wheelY: "zoomY"})
        );

        // Configure faster tooltips
        gChart.plotContainer.onPrivate("maskRectangle", function () {
            gChart.plotContainer.get("maskRectangle").setAll({
                tooltipDelay: 100
            });
        });

        // Set global tooltip animation settings
        gRoot.interfaceColors.set("fill", am5.color(0x000000));
        gChart.set("tooltip", am5.Tooltip.new(gRoot, {
            animationDuration: 200,
            showDelay: 100
        }));

        const xAxis = gChart.xAxes.push(
            am5xy.DateAxis.new(gRoot, {
                baseInterval: {timeUnit: "hour", count: 1},
                renderer: am5xy.AxisRendererX.new(gRoot, {}),
                tooltip: am5.Tooltip.new(gRoot, {})
            })
        );
        const yAxisLatency = gChart.yAxes.push(
            am5xy.ValueAxis.new(gRoot, {renderer: am5xy.AxisRendererY.new(gRoot, {})})
        );
        const yAxisVolume = gChart.yAxes.push(
            am5xy.ValueAxis.new(gRoot, {renderer: am5xy.AxisRendererY.new(gRoot, {opposite: true})})
        );

        // Remove y-axis grid lines
        yAxisLatency.get("renderer").grid.template.setAll({strokeOpacity: 0});
        yAxisVolume.get("renderer").grid.template.setAll({strokeOpacity: 0});

        // Add axis labels
        xAxis.children.unshift(am5.Label.new(gRoot, {
            text: "Date",
            x: am5.p50,
            centerX: am5.p50
        }));
        yAxisLatency.children.unshift(am5.Label.new(gRoot, {
            text: "Latency",
            rotation: -90,
            y: am5.p50,
            centerX: am5.p50
        }));
        yAxisVolume.children.push(am5.Label.new(gRoot, {
            text: "Volume",
            rotation: 90,
            y: am5.p50,
            centerX: am5.p50,
            x: am5.p100
        }));

        const latencySeries = gChart.series.push(
            am5xy.LineSeries.new(gRoot, {
                name: "Latency",
                xAxis: xAxis,
                yAxis: yAxisLatency,
                valueXField: "date",
                valueYField: "value",
                stroke: am5.color(0x006cff),
                strokeWidth: 2
            })
        );

        const volumeSeries = gChart.series.push(
            am5xy.LineSeries.new(gRoot, {
                name: "Volume",
                xAxis: xAxis,
                yAxis: yAxisVolume,
                valueXField: "date",
                valueYField: "value",
                stroke: am5.color(0xff6600),
                strokeWidth: 2
            })
        );

        const legend = gChart.children.unshift(
            am5.Legend.new(gRoot, {
                centerX: am5.p50,
                x: am5.p50,
                marginBottom: 10
            })
        );
        legend.data.setAll(gChart.series.values);

        latencySeries.bullets.push(function () {
            const bullet = am5.Bullet.new(gRoot, {
                sprite: am5.Circle.new(gRoot, {
                    radius: 3,
                    fill: am5.color(0x006cff),
                    tooltipText: "Latency: {valueY}"
                })
            });
            bullet.get("sprite").set("tooltip", am5.Tooltip.new(gRoot, {
                animationDuration: 150,
                showDelay: 50
            }));
            return bullet;
        });

        volumeSeries.bullets.push(function () {
            const bullet = am5.Bullet.new(gRoot, {
                sprite: am5.Circle.new(gRoot, {
                    radius: 3,
                    fill: am5.color(0xff6600),
                    tooltipText: "Volume: {valueY}"
                })
            });
            bullet.get("sprite").set("tooltip", am5.Tooltip.new(gRoot, {
                animationDuration: 150,
                showDelay: 50
            }));
            return bullet;
        });

        /* helper to load graph data */
        function updateGraph(location, latencies, volume, correlation) {
            // Update the graph title
            document.getElementById('graph-title').textContent = location;

            const corrElem = document.getElementById('correlation-value');
            if (correlation !== null && !isNaN(correlation)) {
                const corr = correlation;
                const corrColor = corr > 0 ? "#2e7d32" : (corr < 0 ? "#c62828" : "#616161");
                corrElem.innerHTML = `Correlation (Latency vs Volume): <b style="color:${corrColor}">${corr.toFixed(3)}</b>`;
            } else {
                corrElem.textContent = "Correlation unavailable";
            }

            const latencyData = latencies.map(([value, timestamp]) => ({
                date: timestamp * 1000,
                value: value
            }));
            const volumeData = volume.map(([value, timestamp]) => ({
                date: timestamp * 1000,
                value: value
            }));
            latencySeries.data.setAll(latencyData);
            volumeSeries.data.setAll(volumeData);
        }

        if (points.length) {
            updateGraph(points[0].location, points[0].latencies, points[0].volume, points[0].correlation);   // initial graph
        }

        const pointSeries = chart.series.push(am5map.MapPointSeries.new(mapRoot, {}));

        pointSeries.bullets.push((root, dataItem) => {
            const sprite = am5.Circle.new(root, {
                radius: 5, fill: am5.color(0x006cff),
                stroke: am5.color(0xffffff), strokeWidth: 1,
                tooltipText: "{location}\nLatency: {latestLatency}"
            });

            /* click → update graph */
            sprite.events.on("click", function (ev) {
                // Get current series data and find the matching point
                const seriesData = pointSeries.data.values;

                // Try to find by checking the dataItem's position in the series
                const dataItems = pointSeries.dataItems;
                const bulletIndex = dataItems.indexOf(ev.target.dataItem);

                const pointData = seriesData[bulletIndex];
                updateGraph(pointData.location, pointData.latencies, pointData.volume);
            });

            return am5.Bullet.new(root, {sprite});
        });

        pointSeries.data.setAll(points);
    });
</script>
</body>
</html>
