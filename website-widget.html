<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>World Latencies Map</title>

    <!-- amCharts v5 -->
    <script src="https://cdn.amcharts.com/lib/5/index.js"></script>
    <script src="https://cdn.amcharts.com/lib/5/map.js"></script>
    <script src="https://cdn.amcharts.com/lib/5/xy.js"></script>   <!-- ← NEW -->
    <script src="https://cdn.amcharts.com/lib/5/geodata/worldLow.js"></script>
    <script src="https://cdn.amcharts.com/lib/5/themes/Animated.js"></script>

    <style>
        html,body{margin:0;height:100%}
        #chartdiv {width:100%;height:460px}
        #graphdiv {width:100%;height:260px}                         /* ← NEW */
        #menu{
            position:absolute;top:8px;left:8px;z-index:10;
            background:#fff;font:14px/1 sans-serif;padding:4px 6px;
            border-radius:6px;box-shadow:0 1px 4px rgba(0,0,0,.15)
        }
    </style>
</head>
<body>
<select id="menu"><option value="all">Show All</option></select>
<div id="chartdiv"></div>
<div id="graphdiv"></div>                                      <!-- ← NEW -->

<script>
    /* ---------- 1. DATA ---------- */
    const raw = [
        { title:"JFK (New York)", coords:[-73.778137, 40.641312],
            category:"North America", latency:"17 ms",
            latencies:[[0, 1754118650.338193], [1, 1754122250.338193], [2, 1754125850.338193]],
            volume:[[1000, 1754118650.338193], [2000, 1754122250.338193], [1500, 1754125850.338193]]
        },
        { title:"LHR (London)",   coords:[-0.454296, 51.470020],
            category:"Europe", latency:"23 ms",
            latencies:[[1, 1754118650.338193], [2, 1754122250.338193], [2, 1754125850.338193]],
            volume:[[1200, 1754118650.338193], [1500, 1754122250.338193], [1500, 1754125850.338193]]
        },
        { title:"PEK (Beijing)",  coords:[116.597504, 40.072498],
            category:"Asia", latency:"44 ms",
            latencies:[[2, 1754118650.338193], [3, 1754122250.338193], [2, 1754125850.338193]],
            volume:[[1000, 1754118650.338193], [1000, 1754122250.338193], [1200, 1754125850.338193]]
        }
    ];
    const points = raw.map(p => ({ ...p, geometry:{type:"Point", coordinates:p.coords} }));

    /* ---------- 2. MAP ---------- */
    am5.ready(function(){

        /* ----- Map ----- */
        const mapRoot = am5.Root.new("chartdiv");
        mapRoot.setThemes([am5themes_Animated.new(mapRoot)]);

        const chart = mapRoot.container.children.push(
            am5map.MapChart.new(mapRoot,{panX:"rotateX",panY:"rotateY",
                wheelX:"zoom",wheelY:"zoom",projection:am5map.geoEqualEarth()})
        );

        const polygonSeries = chart.series.push(
            am5map.MapPolygonSeries.new(mapRoot,{
                geoJSON:am5geodata_worldLow, exclude:["AQ"],
                fill:am5.color(0x6fc5a2), stroke:am5.color(0x4e9477)
            }));
        polygonSeries.mapPolygons.template.setAll({strokeOpacity:.6,fillOpacity:.8});

        /* ---------- 3. GRAPH ---------- */
        const gRoot = am5.Root.new("graphdiv");
        gRoot.setThemes([am5themes_Animated.new(gRoot)]);

        const gChart = gRoot.container.children.push(
            am5xy.XYChart.new(gRoot,{panX:true,panY:true,wheelX:"zoomX",wheelY:"zoomY"})
        );
        
        // Configure faster tooltips
        gChart.plotContainer.onPrivate("maskRectangle", function() {
            gChart.plotContainer.get("maskRectangle").setAll({
                tooltipDelay: 100
            });
        });
        
        // Set global tooltip animation settings
        gRoot.interfaceColors.set("fill", am5.color(0x000000));
        gChart.set("tooltip", am5.Tooltip.new(gRoot, {
            animationDuration: 200,
            showDelay: 100
        }));

        const xAxis = gChart.xAxes.push(
            am5xy.ValueAxis.new(gRoot,{renderer:am5xy.AxisRendererX.new(gRoot,{})})
        );
        const yAxisLatency = gChart.yAxes.push(
            am5xy.ValueAxis.new(gRoot,{renderer:am5xy.AxisRendererY.new(gRoot,{})})
        );
        const yAxisVolume = gChart.yAxes.push(
            am5xy.ValueAxis.new(gRoot,{renderer:am5xy.AxisRendererY.new(gRoot,{opposite:true})})
        );
        
        // Remove y-axis grid lines
        yAxisLatency.get("renderer").grid.template.setAll({strokeOpacity: 0});
        yAxisVolume.get("renderer").grid.template.setAll({strokeOpacity: 0});
        
        // Add axis labels
        yAxisLatency.children.unshift(am5.Label.new(gRoot, {
            text: "Latency",
            rotation: -90,
            y: am5.p50,
            centerX: am5.p50
        }));
        yAxisVolume.children.push(am5.Label.new(gRoot, {
            text: "Volume",
            rotation: 90,
            y: am5.p50,
            centerX: am5.p50,
            x: am5.p100
        }));

        const latencySeries = gChart.series.push(
            am5xy.LineSeries.new(gRoot,{
                xAxis:xAxis,
                yAxis:yAxisLatency,
                valueXField:"x", 
                valueYField:"y",
                stroke:am5.color(0x006cff),
                strokeWidth:2
            })
        );
        
        const volumeSeries = gChart.series.push(
            am5xy.LineSeries.new(gRoot,{
                xAxis:xAxis,
                yAxis:yAxisVolume,
                valueXField:"x", 
                valueYField:"y",
                stroke:am5.color(0xff6600),
                strokeWidth:2
            })
        );
        
        latencySeries.bullets.push(function() {
            const bullet = am5.Bullet.new(gRoot, {
                sprite: am5.Circle.new(gRoot, {
                    radius: 3,
                    fill: am5.color(0x006cff),
                    tooltipText: "Latency: {valueY}"
                })
            });
            bullet.get("sprite").set("tooltip", am5.Tooltip.new(gRoot, {
                animationDuration: 150,
                showDelay: 50
            }));
            return bullet;
        });
        
        volumeSeries.bullets.push(function() {
            const bullet = am5.Bullet.new(gRoot, {
                sprite: am5.Circle.new(gRoot, {
                    radius: 3,
                    fill: am5.color(0xff6600),
                    tooltipText: "Volume: {valueY}"
                })
            });
            bullet.get("sprite").set("tooltip", am5.Tooltip.new(gRoot, {
                animationDuration: 150,
                showDelay: 50
            }));
            return bullet;
        });

        /* helper to load graph data */
        function updateGraph(title, latencies, volume){
            const latencyData = latencies.map(([y,x])=>({x,y}));
            const volumeData = volume.map(([y,x])=>({x,y}));
            latencySeries.data.setAll(latencyData);
            volumeSeries.data.setAll(volumeData);
        }
        updateGraph(points[0].title, points[0].latencies, points[0].volume);   // initial graph

        const pointSeries = chart.series.push(am5map.MapPointSeries.new(mapRoot,{}));

        pointSeries.bullets.push((root,dataItem)=>{
            const sprite = am5.Circle.new(root,{
                radius:5, fill:am5.color(0x006cff),
                stroke:am5.color(0xffffff), strokeWidth:1,
                tooltipText:"{title}\nLatency: {latency}"
            });

            /* click → update graph */
            sprite.events.on("click", function (ev) {
                // Get current series data and find the matching point
                const seriesData = pointSeries.data.values;
                
                // Try to find by checking the dataItem's position in the series
                const dataItems = pointSeries.dataItems;
                const bulletIndex = dataItems.indexOf(ev.target.dataItem);
                
                const pointData = seriesData[bulletIndex];
                updateGraph(pointData.title, pointData.latencies, pointData.volume);
            });

            return am5.Bullet.new(root,{sprite});
        });

        pointSeries.data.setAll(points);

        /* ----- Filter menu ----- */
        const menu = document.getElementById("menu");
        [...new Set(points.map(p=>p.category))].sort().forEach(cat=>{
            const o=document.createElement("option"); o.value=cat;o.textContent=cat;menu.appendChild(o);
        });
        menu.addEventListener("change",()=>{
            const sel=menu.value;
            pointSeries.data.setAll(sel==="all"?points:points.filter(p=>p.category===sel));
        });
    });
</script>
</body>
</html>
